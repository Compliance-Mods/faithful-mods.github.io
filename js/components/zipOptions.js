/* global Vue */
/* eslint no-multi-str: 0 */

try {
  let NAME;
} catch(_e) {}
NAME = 'Compliance Mods';

Vue.component('zip-options', {
  template:
    '<div id="zipOptions">\
      <h4 class="my-3">\
        <label for="aoe" class="d-inline-block noselect">Advanced options </label> <input id="aoe" type="checkbox" v-model="advancedOptionsEnabled" />\
      </h4>\
      <div v-show="advancedOptionsEnabled" id="advancedOptions">\
        <div class="form-row">\
          <div class="form-group col-md-4">\
            <label for="compressionSelect" class="d-block pb-1">Compression level</label>\
            <select id="compressionSelect" class="form-control custom-select" v-model="compressionChosen">\
              <template v-for="(ct, ctindex) in compressionTypes">\
                <optgroup :label="ct" :key="ct">\
                  <option v-for="cl in compressionLevels.slice(!!ctindex ? 1 : 0, !ctindex ? 1 : compressionLevelsAvailable)" :key="cl.value" :value="cl.value" :selected="cl.value == compressionChosen">{{ cl.label }}</option>\
                </optgroup>\
              </template>\
            </select>\
          </div>\
          <div class="form-group col-md-4">\
            <label for="archiveName" class="d-block pb-1">Archive name</label>\
            <input type="text" autocomplete="false" name="archiveName" :class="{ \'form-control\': true, empty: !archiveName.trim() }" v-model="archiveName" id="archiveName" placeholder="Leave empty to generate a unique name">\
          </div>\
          <clear-database></clear-database>\
        </div>\
      </div>\
    </div>',
  data: function () {
    return {
      advancedOptionsEnabled: false,
      compressionDefault: 7,
      compressionChosen: 7, // 7 is default compression for ZIP archives
      compressionLevelsAvailable: 10,
      compressionTypes: ['STORE', 'DEFLATE'],
      specialCompressionLabels: {
        '0': 'No compression',
        '1': 'Best speed',
        '7': 'Recommanded',
        '9': 'Best compression'
      },
      archiveName: ''
    }
  },
  computed: {
    chevron: function () {
      return 'fa-caret-' + (this.advancedOptionsEnabled ? 'up' : 'down')
    },
    compressionLevels: function () {
      const result = []
      for (let i = 0; i < this.compressionLevelsAvailable; ++i) {
        result.push({
          value: i,
          label: (String(i) in this.specialCompressionLabels) ? i + ` (${this.specialCompressionLabels[i]})` : String(i)
        })
      }

      return result
    },
    compressionTypeChosen: function () {
      return this.compressionTypes[(this.compressionLevelChosen > 0) * 1]
    },
    compressionLevelChosen: function () {
      return this.advancedOptionsEnabled ? this.compressionChosen : this.compressionDefault
    },
    zipOptions: function () {
      const result = {
        type: 'blob',
        comment: 'Resource pack generated by ' + NAME,
        compression: this.compressionTypeChosen
      }

      if (this.compressionTypeChosen === this.compressionTypes[1]) { // if DEFlATE compression chosen
        result.compressionOptions = {
          level: this.compressionLevelChosen
        }
      }

      return result
    },
    customArchiveName: function () {
      return (this.advancedOptionsEnabled && this.archiveName !== '') ? this.archiveName : undefined
    }
  },
  watch: {
    archiveName: function (newValue, oldValue) {
      if (oldValue !== newValue) {
        const changed = newValue.trim()
        if (changed !== newValue) {
          this.archiveName = changed
        }
      }
    }
  },
  mounted: function () {
    this.$root.$refs.zipOptions = this
  }
})
